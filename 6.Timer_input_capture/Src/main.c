/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint32_t current_CCR=0;
uint32_t previous_CCR=0;
uint32_t difference = 0;

void gpio_initialize()
{
	// LED Initialize
	RCC->AHB1ENR |= (1<<2);			//enable clock for GPIOC
	GPIOC->MODER &= ~(3<<12);
	GPIOC->MODER |= (2<<12);		// Select Alternate function PC6
	GPIOC->AFR[0] &= ~(0xF<<24);
	GPIOC->AFR[0] |= (2<<24);		// AF2 Alternate TIM3_CH1 285
	GPIOC->OTYPER &= ~(1<<6);		//push pull output
	GPIOC->OSPEEDR &= ~(3<<12);
	GPIOC->OSPEEDR |= (1<<12);		// medium speed


	//switch initialize
	RCC->AHB1ENR |= (1<<1);			//GPIOB Clock enable
	GPIOB->MODER &= ~(3<<6);		// Clear Mode of PB3
	GPIOB->MODER |= (2<<6);			// Set alternate function mode of PB3
	GPIOB->AFR[0] &= ~(0xF<<12);	// clear alt setting of PB3
	GPIOB->AFR[0] |= (1<<12);		// AF1 is selected for PB3 (Timer 2 ch 2)
}

void TIM3_initialize()
{
	RCC->APB1ENR |= (1<<1);			// enable Timer 3 Clock
	TIM3->PSC = 0;					// Prescaler as 0
	TIM3->ARR = 16000-1;			// set for 1KHz frequency
	TIM3->CNT = 0;
	TIM3->CCMR1 &= ~(7<<4);
	TIM3->CCMR1 |= (6<<4);			// PWM1 mode selection
	TIM3->CCER |= (1<<1);			// Active Low polarity
	TIM3->CCER |= (1<<0);			// enable TIM3_CH1 to PC6
	TIM3->CR1 |= (1<<0);			// start timer 3
}

void TIM2_initialize()
{
	RCC->APB1ENR |= (1<<0);
	TIM2->PSC = 16000-1;		// set PSC for 1KHz
	TIM2->ARR = 0xFFFF-1;		// set ARR to maximum RM 649
	TIM2->CNT = 0;				// reset counter register
	TIM2->CCMR1 &= ~(0xFF00);	//resetting higher 8 bit (CH2) mode RM636
	TIM2->CCMR1 |= (1<<8);		// Set Input option for TIM2_CH2 RM 636
	TIM2->CCMR1 |= (3<<12);		// sampling  N=8
	TIM2->CCER |= (1<<5);		// falling edge detection(active low) RM 640
	TIM2->CCER &= ~(1<<7);		// falling edge selection ( noninverted/rising edge)
	TIM2->CCER |= (1<<4);		// Timer 2 ch2 connect to GPIO PB3 (configure as a output pin)
	TIM2->CR1 |= (1<<0);		// start timer
}



/*
 * As per the Input Capture  mode based on How fast you are clicking the
 * SWT2 you will get less difference value which will be given as
 * duty cycle for the PWM of LED connected to PC6
 */
int main(void)
{
	gpio_initialize();
	TIM3_initialize();
	TIM2_initialize();
	for(;;)
	{
		while(!(TIM2->SR & (1<<2)));		//check for capture RM 676
		current_CCR = TIM2->CCR2;			// copy CCR2 value
		difference = current_CCR - previous_CCR;	// calculate the difference
		previous_CCR = current_CCR;			// store current to previous
		TIM3->CCR1 = difference;			// Load value to CCR1 of TIM3 for PWM

	}
}
