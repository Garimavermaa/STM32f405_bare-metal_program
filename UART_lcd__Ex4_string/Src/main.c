/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

#include "lcd.h"
#include <stdio.h>
#include <stdlib.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


/******PROCEDURE************/
/* Step 1: Identify the bus clock , APB1 bus (UART4), AHB1 (PORTA)*/
/*Step 2: Config PORTA for UART4 PA0-> TX, PA1->RX*/
/* 2.1-> Select Mode of operation for PA0 & PA1 as alternate fn*/
/* 2.2-> AFRL alternate function as AF8 (PA0 & PA1)*/
/*2.4-> select speed as high speed in PA0 & PA1*/
/*Step 3: config UART*/

char rx_data[20];
volatile uint8_t ind;
volatile uint8_t rflag;

void UART2_config()
{
	/*UART port pin config*/
	RCC->AHB1ENR |= (1<<0);			// enable GPIOA clock
	GPIOA->MODER &= ~(0xF<<4);		// enable alternate fn in PA2 & PA3
	GPIOA->MODER |=(0xA<<4);
	GPIOA->AFR[0] &= ~(0xFF<<8);	// enable UART2 TX & RX function for PA2 & PA3
	GPIOA->AFR[0] |= (0x77<<8);
	GPIOA->OSPEEDR |= (0xF<<2);		// set output speed as high speed
	/*UART4 config */
	RCC->APB1ENR |= (1<<17); 		// enable UART2 clock
	USART2->CR1 |= (1<<13); 			//Uart2 is enabled
	USART2->CR1 &= ~(1<<12); 		//set 8bit data mode

 	USART2->BRR = 0x683;				// baudrate for 9600

 	USART2->CR1 |= (1<<5); 			// Uart2 Rx interrupt enable
 	USART2->CR1 |= (3<<2); 			// Tx & Rx enable
 	NVIC_EnableIRQ(USART2_IRQn);		// UART2 Rx interrupt enable in NVIC
}

void UART2_sendchar(uint8_t x)
{
	USART2->DR = x;						/*Place the data in DR register for transmitting*/
	while(!(USART2->SR & (1<<6)));		/*Wait until TC (Transmission complete) is 1*/
}

void UART2_sendstring(char *string)
{
	while(*string)
	{
		UART2_sendchar(*string++);
	}
}

void USART2_IRQHandler()
{
//	while(!(UART4->SR & (1<<5)));		/*wait until RXNE bit is set which indicates data receive*/
	char ch;
	ch = USART2->DR;
	if (rflag) return;

	rx_data[ind]= ch;
	if (ch != '\n' && ch != '\r')
	{
	 if (ind<19)
	  ind++;
	 else
	   rflag = 1;
	 }
	else
	{
	  rx_data[ind]= '\0';
	  rflag = 1;
	 }
	//rx_data[ind]='\0';     // why terminate here?
}

void display_recv (void)
{
		  clear_LCD ();
		  lprint (0x80,rx_data);
		  rflag = 0;
		  ind = 0;
		  //for (int i=0; i<30000; i++);   // this for the display to be visible for some time
}

int main(void)
{
	UART2_config();
	LcdInit ();
//	lprint (0x80,"Hello");
//	while (1){}
	while (1)
	{
	  UART2_sendstring(" WELCOME\n");
	  for (int k=0; k<1000; k++){}
	  if (rflag)
	  {
	    display_recv ();
	    for (int i=0; i<300000; i++);
	   }

	  UART2_sendstring(" ALL\n");
	  for (int k=0; k<1000; k++){}
	  if (rflag)
	  {
	    display_recv ();
	    for (int i=0; i<300000; i++);
	   }

	  for (int i=0; i<50000; i++);
//	  clear_LCD ();
//	  lprint (0x80,"Hello");
//	  for (int i=0; i<50000; i++);
	}


}
