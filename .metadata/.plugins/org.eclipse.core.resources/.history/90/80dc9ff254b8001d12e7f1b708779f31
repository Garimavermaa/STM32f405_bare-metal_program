/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


/******PROCEDURE************/
/* Step 1: Identify the bus clock , APB1 bus (UART4), AHB1 (PORTA)*/
/*Step 2: Config PORTA for UART4 PA0-> TX, PA1->RX*/
/* 2.1-> Select Mode of operation for PA0 & PA1 as alternate fn*/
/* 2.2-> AFRL alternate function as AF8 (PA0 & PA1)*/
/*2.4-> select speed as high speed in PA0 & PA1*/
/*Step 3: config UART*/

char rx_data[20];
uint8_t ind=0;
uint32_t source_add,dest_add;
void UART4_config()
{
	/*UART port pin config*/
	RCC->AHB1ENR |= (1<<0);			// enable GPIOA clock
	GPIOA->MODER &= ~(0xF<<0);		// enable alternate fn in PA0 & 1
	GPIOA->MODER |=(0xA<<0);
	GPIOA->AFR[0] &= ~(0xFF<<0);	// enable UART4 TX & RX function for PA0 & PA1
	GPIOA->AFR[0] |= (0x88<<0);
	GPIOA->OSPEEDR |= (0xF<<0);		// set output speed as high speed
	/*UART4 config */
	RCC->APB1ENR |= (1<<19); 		// enable UART4 clock
	UART4->CR1 |= (1<<13); 			//Uart4 is enabled
	UART4->CR1 &= ~(1<<12); 		//set 8bit data mode
 	UART4->BRR = 0x683;				// baudrate for 9600
// 	UART4->CR1 |= (1<<5); 			//Uart4 Rx interrupt enable
 	UART4->CR3 |= (1<<6);
 	UART4->CR1 |= (3<<2); 			// TE & RE enable
// 	NVIC_EnableIRQ(UART4_IRQn);		// UART4 Rx interrupt enable in NVIC
}

void DMA1_config()
{
	RCC->AHB1ENR |= (1<<21);	//DMA1 clock enable
	/*TX confiq*/
	DMA1_Stream2->CR = 0x00000000;	// disable stream2
	DMA1_Stream2->PAR = (uint32_t)&UART4->DR;	//set peri addres as uart
	DMA1_Stream2->M0AR = (uint32_t)&rx_data;	//memory add as RX data
	DMA1_Stream2->NDTR = 20;
	DMA1_Stream2->CR |= (4<<25);	//channel 4 selection
	DMA1_Stream2->CR &= ~(3<<6); 	//direction - peripheral to memory
	DMA1_Stream2->CR &= ~(3<<11);	// data size as 8bit
	DMA1_Stream2->CR &= ~(3<<13);	// memory data size as 8bit
	DMA1_Stream2->CR |= (1<<8);		// circular mode
	DMA1_Stream2->CR &= ~(1<<9);	// disable peri increment
	DMA1_Stream2->CR |= (1<<10);	// enable memory increment
	DMA1_Stream2->CR &= ~(3<<16);	// set low priority
	DMA1_Stream2->CR |= (1<<0);		// enable DMA

}
void UART4_sendchar(uint8_t x)
{
	UART4->DR = x;						/*Please the data in DR register for transmitting*/
	while(!(UART4->SR & (1<<6)));		/*Wait until TC (Transmission complete) is 1*/
}

void UART4_sendstring(char *string)
{
	while(*string)
	{
		UART4_sendchar(*string++);
	}
}
//void UART4_IRQHandler()
//
//{
//	while(!(UART4->SR & (1<<5)));		/*wait until RXNE bit is set which indicates data receive*/
//	rx_data[ind]=UART4->DR;
//	ind++;
//	rx_data[ind]='\0';
//}

int main(void)
{
	UART4_config();
	DMA1_config();

		while(1)
		{
			UART4_sendstring(" WELCOME ALL");
			if(DMA1->LISR & (1<<5))				/* check for buffer overflow*/
			{
				DMA1->LIFCR |= (1<<5);			/* clear buffer */
			}
			for(uint32_t x=0;x<200000;x++);
		}
}
